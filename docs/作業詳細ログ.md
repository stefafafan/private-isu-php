# 作業詳細ログ

ここには private-isu を解くにあたって実施している詳細の作業ログを記載します。

## 事前準備

競技用インスタンスにsshする。

```sh
ssh -i <.pemファイル> ubuntu@<Public IPv4 address>
```

isuconユーザに切り替えて、ホームディレクトリに移動

```sh
sudo su isucon
cd ~
```

### 初期データの準備

```sh
mkdir private_isu/webapp/sq
cd private_isu/
make init
```

MySQLコマンドへデータを流し込む (数分かかる)。

```sh
bunzip2 -c webapp/sql/dump.sql.bz2 | mysql -uisuconp -pisuconp
```

### 鍵の登録、~/.ssh/configの作成

`~/.ssh/authorized_keys` ファイルを作成する。isuconユーザに対して権限を付与する。

```sh
sudo mkdir ~/.ssh
sudo touch ~/.ssh/authorized_keys
sudo chown -R isucon:isucon ~/.ssh
```

GitHubの鍵を登録。

```sh
curl https://github.com/<あなたのGitHubユーザID>.keys >> ~/.ssh/authorized_keys
```

ログアウトし、pemファイルなしでログインできることを確認する。

```sh
ssh isucon@<Public IPv4 addressの値>
```

ベンチマーク用インスタンスでも同様の作業を実施する。

```sh
# ローカル
ssh -i <.pemファイル> ubuntu@<Public IPv4 address>

# サーバ上
sudo su isucon
cd ~
sudo mkdir ~/.ssh
sudo touch ~/.ssh/authorized_keys
sudo chown -R isucon:isucon ~/.ssh
curl https://github.com/<あなたのGitHubユーザID>.keys >> ~/.ssh/authorized_keys

# ローカルで確認
ssh isucon@<Public IPv4 addressの値>
```

必要な設定が終わったので、 `~/.ssh/config` を手元向けに作成する。中身は以下のような形（IPアドレスの値は実際の値と置き換える）。

```sh
Host isu01
  User isucon
  HostName <Public IPv4 addressの値>
Host isubench
  User isucon
  HostName <Public IPv4 addressの値>
```

設定が終わったら以下のようにssh可能になる。

```sh
ssh isu01
ssh isubench
```

## 動作確認とベンチマーカーの実行

競技用インスタンスのPublic IPv4 addressに直接ブラウザで (httpで) アクセスしたら「Iscogram」という名前のアプリが確認できる。

ベンチマーカーの実行はベンチマーカー用インスタンス上で以下のように実行する。

```sh
# sshした上で、
ssh isubench

# ベンチマーク実行
/home/isucon/private_isu.git/benchmarker/bin/benchmarker -u /home/isucon/private_isu.git/benchmarker/userdata -t http://<競技用インスタンスのPrivate IPv4 addresseの値>
```

以下のようなログが出力されます。

```sh
{"pass":true,"score":1026,"success":889,"fail":0,"messages":[]}
```

## rsync で必要なファイルだけ手元に持ってきて、GitHubへpushする

`isu01` 上のディレクトリ構成の感じを見つつ、以下のようなコマンドで不要なディレクトリを除外しつつ `webapp` 配下を持ってくる。

```sh
rsync -av --exclude 'sql' --exclude 'golang' --exclude 'node' --exclude 'ruby' isu01:~/private_isu/webapp ./
```

`webapp/docker-compose.yml` と `webapp/etc` は正直いらなそうなので手元から除外しつつ、必要なファイルだけ GitHub にpushしておく。

まず `.gitignore` に `vendor` を入れておく。

```.gitignore
vendor
```

その上で残りの `webapp` もcommitしてpushする。

## webapp/php 以下をサーバへ rsync

手元で composer install しつつ

```sh
cd webapp/php
composer install
```

webapp/php のみ rsyncでアップロードする。

```sh
rsync -av webapp/php/ isu01:~/private_isu/webapp/php/
```

## PHP実装に切り替え

[マニュアル](https://github.com/catatsuy/private-isu/blob/master/manual.md) に従ってPHP実装に切り替える。

```sh
sudo systemctl stop isu-ruby
sudo systemctl disable isu-ruby
sudo rm /etc/nginx/sites-enabled/isucon.conf
sudo ln -s /etc/nginx/sites-available/isucon-php.conf /etc/nginx/sites-enabled/
sudo systemctl reload nginx
sudo systemctl start php8.3-fpm
sudo systemctl enable php8.3-fpm
```

ログを確認する
```sh
$ sudo journalctl -f -u php8.3-fpm
Nov 28 23:15:25 ip-172-31-1-111 systemd[1]: Starting php8.3-fpm.service - The PHP 8.3 FastCGI Process Manager...
Nov 28 23:15:25 ip-172-31-1-111 systemd[1]: Started php8.3-fpm.service - The PHP 8.3 FastCGI Process Manager.
```

nginxのエラーログを tail しながらアプリをWebで開くと以下のようなエラーが出力される。

```sh
$ sudo tail -f /var/log/nginx/error.log
2024/11/28 23:16:56 [error] 3454#3454: *1042 FastCGI sent in stderr: "PHP message: PHP Fatal error:  Uncaught PDOException: SQLSTATE[HY000] [1698] Access denied for user 'root'@'localhost' in /home/isucon/private_isu/webapp/php/index.php:57
```

`/home/isucon/private_isu/webapp/php/index.php` の57行目を確認する。DBに接続できていない、そして root ユーザで接続しようとしている。

```php
    return new PDO(
        "mysql:dbname={$config['db']['database']};host={$config['db']['host']};port={$config['db']['port']};charset=utf8mb4",
        $config['db']['username'],
        $config['db']['password']
    );
```

ここでサーバ上の `env.sh` をみると以下のような値が設定されているので本来ならこれで動きそうだけど..

```sh
ISUCONP_DB_USER=isuconp
ISUCONP_DB_PASSWORD=isuconp
ISUCONP_DB_NAME=isuconp
```

手抜きしてアプリを修正して ([c642a45](https://github.com/stefafafan/private-isu-php/commit/c642a45ff4fdfa3a8e357c3a14aaefd3487e19c8)) なんとかする。

rsyncでデプロイしなおしたら無事PHP実装が動いていることをブラウザ上で確認できる。ベンチを回して点数がでたら無事成功。

```sh
{"pass":true,"score":3288,"success":3085,"fail":0,"messages":[]}
```

## スロークエリログの有効化とpt-query-digestの設定

MySQLの設定が `/etc/mysql/mysql.conf.d/mysqld.cnf` にあるので、それをひとまず手元に持ってくる。

```sh
mkdir -p ./etc/mysql/mysql.conf.d
rsync -av isu01:/etc/mysql/mysql.conf.d/mysqld.cnf ./etc/mysql/mysql.conf.d
```

スロークエリログを有効化する: [dd32d11](https://github.com/stefafafan/private-isu-php/commit/dd32d11b4e3c6020159f764cfa028a15ebe34a09)

rsyncでサーバ上へ反映し、mysqlを再起動する。sudo権限が必要なので、 `--rsync-path="sudo rsync"` というオプションをつけている。

```sh
# ローカル上で実行
rsync -av --rsync-path="sudo rsync" ./etc/mysql/mysql.conf.d/ isu01:/etc/mysql/mysql.conf.d/

# サーバ上で
sudo systemctl restart mysql
```

`systemctl status mysql.service` と実行して特にエラー表示になっていなければ成功。

```sh
$ systemctl status mysql.service
● mysql.service - MySQL Community Server
     Loaded: loaded (/usr/lib/systemd/system/mysql.service; >
     Active: active (running) since Thu 2024-11-28 23:39:45 >
    Process: 5119 ExecStartPre=/usr/share/mysql/mysql-system>
   Main PID: 5129 (mysqld)
     Status: "Server is operational"
      Tasks: 38 (limit: 4535)
     Memory: 405.2M (peak: 405.7M)
        CPU: 639ms
     CGroup: /system.slice/mysql.service
             └─5129 /usr/sbin/mysqld
```

次に pt-query-digest を入れます。以下の2行で入ります。

```sh
curl -LO https://percona.com/get/pt-query-digest
sudo install pt-query-digest /usr/local/bin/pt-query-digest
```

pt-query-digest の使い方は、第一引数としてスロークエリログファイルを渡すか、標準入力からパイプして渡すか、どちらでも利用できます。

```sh
# 第一引数に渡す方法
$ sudo pt-query-digest /var/log/mysql/mysql-slow.log

# パイプする方法
$ sudo cat /var/log/mysql/mysql-slow.log | pt-query-digest
```

ベンチマークを回すたびにログファイルが追記されていくのでベンチ実行前に `truncate` コマンドで中身を空にしておきましょう。
```sh
sudo truncate -s 0 /var/log/mysql/mysql-slow.log
```

## アクセスログ形式の変更とalpの設定

nginx の設定が `/etc/nginx/nginx.conf` にあるのでそれを手元に持ってくる。

```sh
mkdir -p ./etc/nginx/
rsync -av isu01:/etc/nginx/nginx.conf ./etc/nginx/
```

`/etc/nginx/nginx.conf` の中をみると、 `/etc/nginx/conf.d/*.conf` と `/etc/nginx/sites-enabled/*` がincludeされている。このへんにも関係ある設定がないかサーバ上で様子をみる。

```nginx
	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
```

サーバ上でみると、 `/etc/nginx/conf.d/` 以下は特に何もなさそう。代わりに `/etc/nginx/sites-enabled/isucon-php.conf` が置いてあった。

```sh
$ sudo ls /etc/nginx/conf.d/
$ sudo ls /etc/nginx/sites-enabled/
isucon-php.conf
```

isucon-php.conf も手元に持ってくる。

```sh
mkdir -p ./etc/nginx/sites-enabled
rsync -av isu01:/etc/nginx/sites-enabled/isucon-php.conf ./etc/nginx/sites-enabled
```

これらの設定をGitHubにpushしておく。

コミットしてみたところ、 `/etc/nginx/sites-enabled/isucon-php.conf` は実はシンボリックリンクで、中身は `/etc/nginx/sites-available/isucon-php.conf` にあるということがGitHubの表示からわかる。

実体のほうがほしいので `/etc/nginx/sites-available/isucon-php.conf` を持ってくる。

```sh
rm -rf etc/nginx/sites-enabled/
mkdir -p ./etc/nginx/sites-available
rsync -av isu01:/etc/nginx/sites-available/isucon-php.conf ./etc/nginx/sites-available
```

アクセスログの設定をします。alpはltsv形式でもjson形式でも対応できますが今回はjson形式にしてみましょう。

[alpのREADMEを参考に](https://github.com/tkuchiki/alp/blob/d91a23dc2d71521c5a9e166faf92f68d082fb85f/README.md#json)、 `/etc/nginx/nginx.conf` の設定をします: [b31b876](https://github.com/stefafafan/private-isu-php/commit/b31b8769e0dd1157d3e2a368333ab38cc95fe930)

変更内容をrsyncでサーバに反映します。

```sh
# ローカル上で実行
rsync -av --rsync-path="sudo rsync" ./etc/nginx/nginx.conf isu01:/etc/nginx/nginx.conf

# サーバ上で
sudo systemctl restart nginx
```

alpを入れます。 https://github.com/tkuchiki/alp/releases から最新の `alp_linux_amd64.zip` のリンクをコピーして、以下のようにサーバ上で入れます。

```sh
wget https://github.com/tkuchiki/alp/releases/download/v1.0.21/alp_linux_amd64.zip
unzip alp_linux_amd64.zip
sudo install alp /usr/local/bin/alp
```

alpの使い方はアクセスログを標準入力からパイプして渡す形です。今回はjson形式にしたので、 `alp json` を使います。

```sh
sudo cat /var/log/nginx/access.log | alp json
```

まだベンチを回していないので最初は上手くいきません。一度アクセスログの中身もtruncateしておきましょう。

```sh
sudo truncate -s 0 /var/log/nginx/access.log
```

## PHP向けプロファイラ reliforp/reli-prof を導入する

pt-query-digest と alp でざっくりとボトルネックを知ることはできますが、PHPのアプリケーション内でどこがボトルネックかドリルダウンしたい場合はプロファイラも活用できると便利です。 [reliforp/reli-prof](https://github.com/reliforp/reli-prof) を導入します。以下の記事を丸々参考にしました。

- [Reli を使った PHP 7.x/8.x サービスの計測｜技術ブログ｜北海道札幌市・宮城県仙台市のVR・ゲーム・システム開発 インフィニットループ](https://www.infiniteloop.co.jp/tech-blog/2023/03/profiling-php8-using-reli/)

競技用インスタンス上で reli-prof を入れます。

```sh
composer create-project reliforp/reli-prof
cd reli-prof
```

使い方としては、topコマンド的にどこに負荷がかかっているか知りたい場合は `reli-prof` のディレクトリ内の `reli` コマンドの `i:top` サブコマンドを使います。 `-P` オプションが必須パラメータでここでプロセス名を正規表現でマッチさせる必要があります。 private-isu の場合は `php-fpm` が起動しているのでこれを指定します。
```sh
sudo ./reli i:top -P "php-fpm"
```

psコマンドを使って動いているプロセスの名前を確認している様子:

```sh
$ ps auxfw | grep fpm
root         594  0.0  0.6 209068 23900 ?        Ss   11:31   0:00 php-fpm: master process (/etc/php/8.3/fpm/php-fpm.conf)
isucon      2071  0.1  0.4 209632 19228 ?        S    11:49   0:00  \_ php-fpm: pool www
isucon      2150  0.0  0.4 209632 19332 ?        S    11:49   0:00  \_ php-fpm: pool www
isucon      2181  0.0  0.4 209632 18792 ?        S    11:50   0:00  \_ php-fpm: pool www
isucon      2214  0.0  0.0   7076  2176 pts/0    S+   11:51   0:00              \_ grep fpm
```

reli実行中にブラウザでアプリを開いて何度かリロードするとリアルタイムに状況が反映されます。以下の例をみると `PDOStatement::execute` が重いっぽいということがわかります。

```sh
{php-fpm}
samp_count=199  func_count=44  total_count=6445

total_incl total_excl incl excl     % name
      4730       4729  178  178 89.45 PDOStatement::execute
      1679       1679   21   21 10.55 session_start
     14281          0  534    0  0.00 Slim\MiddlewareDispatcher::handle
      6446          0  199    0  0.00 <main>
      4663          3  178    0  0.00 class@anonymous::make_posts
...
```

top的な使い方なら以上ですが、FlameGraph形式でみれるようにするために `i:daemon` サブコマンドを使いつつ、結果をファイルに出力します。

```sh
sudo ./reli i:daemon -P "php-fpm" > traces.log
```

何度かブラウザをリロードして満足したら上記のコマンドを止めます。そして、 `c:flamegraph` コマンドを使ってsvgを作成します。

```sh
./reli c:flamegraph < traces.log > traces.svg
```

svg画像の結果を見たいので、ローカルへとrsyncします。

```sh
rsync isu01:~/reli-prof/traces.svg ./
```

あとは `open traces.svg` など実行して、デフォルトのアプリケーション (Chromeなど) でsvgファイルを開きます。以下のようなflamegraphが確認できます。横の軸で長いところがCPUを長く占有しているので、ぱっとみ `make_posts` が結構時間かかっていそうだな、みたいなことがこれを見てわかります。

![First Flamegraph Result](./images/traces.svg)

`traces.log` の今回の内容も不要になったので truncate コマンドで中身をクリアしておきます。

```sh
truncate -s 0 ./traces.log
```

nginxのアクセスログ、mysqlのスロークエリログとともにtruncateが完了したらいよいよベンチを回してボトルネックを探す準備ができました。
